title: Somente dobras e cavalos

text: Anteriormente quando estávamos lidando com recursividade, notamos um tema em comum em várias funções recursivas que trabalham em listas. Normalmente tínhamos um caso limite para a lista vazia. Introduzíamos o padrão [code]x:xs[/code] e então fazíamos algo que envolvia um único elemento e o resto da lista. Este padrão é muito comum, por isso foram introduzidas algumas funções bastante úteis para o encapsulá-lo. Estas funções são chamadas de <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)" title="_blank">"folds"</a> (livremente traduzidas aqui como <i>dobras</i>). Elas são como a função [code]map[/code], só que reduzem a lista em um valor único.

Uma <i>fold</i> recebe uma função binária, um valor inicial (gosto de chamá-lo de acumulador) e uma lista que será dobrada em diversas etapas até se tornar uma dobra única. A função binária recebe dois parâmetros. A função binária é chamada com o acumulador e o primeiro (ou último) elemento e produz um novo acumulador. Então, a função binária é chamada novamente com o novo acumulador e o agora novo primeiro (ou último) elemento, e assim por diante. Uma vez percorrida toda a lista, apenas acumulador permanece, que é o valor a que reduzimos a lista. 

Primeiro vamos dar uma olhada na função [function]foldl[/function], também chamada de <i>left fold</i> (dobra à esquerda). Ela dobra a lista a partir do lado esquerdo. A função binária é aplicada entre o valor inicial e a <i>cabeça</i> da lista. Isto produz um novo valor acumulado e a função binária será chamada com este valor e o próximo elemento, etc. 

Vamos implementar novamente a [code]sum[/code], só que dessa vez utilizando uma dobra no lugar da recursão explícita.

Testando, um dois três:

Vamos dar uma olhada melhor em como esta dobra funciona. [code]\acc x -&gt; acc + x[/code] é a função binária. [code]0[/code] é o valor inicial e [code]xs[/code] é a lista a ser dobrada. Primeiramente, [code]0[/code] é usado como parâmetro [code]acc[/code] na função binária e [code]3[/code] é usado como sendo o parâmetro [code]x[/code] (ou o elemento atual).[code]0 + 3[/code] produz um [code]3[/code] e se torna o novo valor do acumulador, por assim dizer. Logo depois, [code]3[/code] é usado como sendo o valor acumulado e [code]5[/code] como sendo o elemento atual e [code]8[/code] passa a ser o novo acumulador. Indo adiante, [code]8[/code] é o valor acumulado, [code]2[/code] é o elemento atual, então o novo valor do acumulador é [code]10[/code]. Finalmente, aquele [code]10[/code] é utilizado como o valor acumulado e [code]1[/code] é o elemento atual, produzindo um [code]11[/code]. Parabéns, você fez uma dobra!

Este diagrama profissional à esquerda ilustra como uma dobra acontece, passo a passo (dia a dia!). O número verde escuro é o valor acumulado. Você pode ver como a lista é meio que consumida a partir da esquerda pelo acumulador. Om nom nom nom! Se levarmos em conta que funções são <i>curried</i>, poderemos escrever esta implementação mais sucintamente, dessa maneira:

A função lambda [code](\acc x -&gt; acc + x)[/code] é a mesma que [code](+)[/code]. Nós podemos omitir o [code]xs[/code] como um parâmetro porque chamar [code]foldl (+) 0[/code] irá retornar uma função que recebe uma lista. Genericamente, se você tem uma função como [code]foo a = bar b a[/code], você poderá reescrevê-la como [code]foo = bar b[/code], por causa do currying.

Vamos implementar uma outra função com uma dobra à esquerda antes de seguir com dobras à direita. Tenho certeza que todos vocês já sabem que [code]elem[/code] verifica se um valor é parte de uma lista, então nem vou falar disso novamente (oops, já falei!). Vamos implementar isto com a dobra à esquerda.

Bem, bem, bem, o que temos aqui? O valor inicial e o acumulador aqui são valores booleanos. O tipo do valor acumulado e do resultado final são sempre o mesmo quando lidamos com dobras. Lembre-se que se você em algum momento não souber o que usar como valor inicial, isto te dará alguma idéia. Começamos com [code]False[/code]. Isto faz sentido usarmos [code]False[/code] como valor inicial. Nós assumimos que ele não esta lá. Também, se chamarmos uma dobra em uma lista vazia, o resultado será justamente o valor inicial. Então vamos verificar se o elemento inicial é o elemento que estamos procurando. Se for, setamos o acumulado como [code]True[/code]. Se não, nós simplesmente não mudamos o acumulador. Se ele era [code]False[/code] antes, permanecerá assim porque o elemento atual não é o que procuramos. Se ele era [code]True[/code], deixamos ele assim.

A dobra à direita, [function]foldr[/function], funciona de forma similar à dobra à esquerda, só que o acumulador começa a consumir os valores a partir da direita. Além disso, as funções binárias das dobras à esquerdas têm o acumulador como o primeiro parâmetro e o valor atual como sendo o segundo parâmetro (como em [code]\acc x -&gt; ...[/code]). As funções binárias das dobras à direita têm o valor atual como primeiro parâmetro e o acumulador como segundo (so [code]\x acc -&gt; ...[/code]). Até que faz sentido que as dobras à direita tenham o acumulador na direita, porque elas dobram a partir do lado direito.

O acumulador (e por isso, o resultado) de uma dobra pode ter qualquer tipo. Ele pode ser um número, um booleano ou mesmo uma nova lista. Vamos implementar a função map com uma dobra à direita. O acumulador será uma lista, e iremos acumulando a lista mapeada elemento por elemento. 

Se nós mapearmos [code](+3)[/code] em [code][1,2,3][/code], acessaremos a lista a partir do lado direito. Pegamos o último elemento, que é [code]3[/code] e aplicamos a função nele, que no final será [code]6[/code]. Então, nós acrescentamos isto à esquerda no acumulador, que era [code][][/code]. [code]6:[][/code] é [code][6][/code] e é agora o acumulador. Nós aplicamos [code](+3)[/code] ao [code]2[/code], que gera [code]5[/code], e acrescentamos à esquerda ([code]:[/code]) isto ao acumulador, e então o acumulador é agora [code][5,6][/code]. Aplicamos [code](+3)[/code] ao [code]1[/code] e acrescentamos à esquerda ele ao acumulador e então o valor final é [code][4,5,6][/code].

É claro, poderíamos ter implementado esta função com a dobra à esquerda também. Ela teria sido [code]map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs[/code], porém o problema é que a função [code]++[/code] é muito mais custosa que [code]:[/code], então normalmente utilizamos dobras à direita quando queremos construir novas listas a partir de uma lista.

Se você reverter a lista, você poderá fazer a dobra direita do mesmo modo que fazemos a dobra esquerda e vice-versa. Algumas vezes você não tem como fazer isso. A função [code]sum[/code] pode ser implementada muito bem do mesmo jeito com uma dobra esquerda e direita. A grande diferença é que a dobra direita funciona em listas infinitas, ao contrario da esquerda que não! Para esclarecer melhor, se você pegar uma lista infinita a partir de um ponto e você dobrá-la a partir da direita, você irá eventualmente descobrir o início da lista. Tanto faz, se você quer pegar uma lista infinita a partir de um ponto e tentar dobrá-la a partir da esquerda, você nunca chegará no fim!

<em>Dobras podem ser usadas para implementar qualquer função onde você percorre uma lista uma única vez, elemento por elemento, e então retorna algo baseado nisso. Sempre que você quiser percorrer uma lista para alguma coisa, é provável que você queira uma dobra.</em> Por isso que dobras vem com mapas e filtros, uma dos tipos mais úteis de funções na programação funcional.

As funções [function]foldl1[/code] e [function]foldr1[/code] funcionam da mesma forma que [code]foldl[/code] e [code]foldr[/code], só que você não precisa informar explicitamente qual o valor inicial. Ele assume que o primeiro (ou último) elemento da lista é o valor inicial da dobra e então inicial a dobra com ele. Com isto em mente, a função [code]sum[/code] pode implementar algo como: [code]sum = foldl1 (+)[/code]. Como eles dependem de pelo menos um elemento para dobrar a lista, isto causará um runtime error caso seja chamado com uma lista vazia.  Por outro lado, [code]foldl[/code] e [code]foldr[/code] trabalham bem com listas vazias. Quando criar uma dobra, pense sobre como isso irá se comportar com uma lista vazia. Se a função não fizer sentido quando tiver uma lista vazia, você provavelmente usará [code]foldl1[/code] ou [code]foldr1[/code] para implementar isso.

Só para te mostrar como dobras são poderosas, vamos implementar algumas funções da biblioteca padrão utilizando dobras:

[code]head[/code] e [code]last[/code] são implementadas melhor pelo uso de pattern matching, mas só para ver, você pode obte-los através do uso de dobras. Nossa definição de [code]reverse'[/code] é bastante clara, eu acho. Nós temos um valor inicial de uma lista vazia e então acessamos nossa lista a partir da esquerda e vamos adicionamos ao nosso valor acumulado. No final, nós construímos uma lista reversa. [code]\acc x -&gt; x : acc[/code] assemelhasse a função [code]:[/code], somente os parâmetros são movimentados. Este é o porque que poderíamos ter escrito nosso reverse como [code]foldl (flip (:)) [][/code].

Outro jeito para esboçar a dobra direita e a esquerda é algo como: digamos que temos uma dobra direita e uma função binária [code]f[/code] com um valor inicial [code]z[/code]. Se formos dobrar a lista [code][3,4,5,6][/code], essencialmente faremos isso: [code] f 3 (f 4 (f 5 (f 6 z)))[/code]. [code]f[/code] é chamado com o último elemento da lista e o valor acumulado, este valor é dado ao valor acumulado para o próximo último valor e assim por diante. Se nós fizermos o [code]f[/code] ser [code]+[/code] e o valor acumulado inicial ser [code]0[/code], aquilo ficará [code] 3 + ( 4 + ( 5 + (6 +0 ) ) ) [/code]. Ou se nós colocarmos o [code]+[/code] como uma função prefixo, aquilo ficaria então [code] (+) 3 ((+) 4 ( (+) 5 ( (+) 6 0) ) )[/code]. De forma similar, fazemos a dobra esquerda com uma lista [code]g[/code] com [code]flip (:)[/code] sendo a função binária e [code][][/code] o valor acumulado (então reverteríamos a lista), isto seria o equivalente a [code]flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6[/code]. E certamente, se executarmos esta expressão, teríamos [code][6,5,4,3][/code].

[function]scanl[/function] e [function]scanr[/function] são como [code]foldl[/code] e [code]foldr[/code], eles só informam todos os estados intermediários do valor acumulado na forma de uma lista. Há também o [code]scanl1[/code] e [code]scanr1[/code], que são idênticos ao [code]foldl1[/code] e [code]foldr1[/code].

Quando usamos o [code]scanl[/code], o resultado final estará no último elemento da lista resultante enquanto o [code]scanr[/code] irá colocar o resultado no primeiro.

Scans são usadas para monitorar a progressão de uma função que pode ser implementada como uma dobra. Vamos responder essa nossa questão: <em>Quantos elementos precisamos ter para somar a raiz de todos os números naturais que excedem 1000?</em>. Para obter o quadrado de todos os números naturais, nós tem que fazer [code]map sqrt [1..][/code]. Agora, para ter a soma, nós temos que fazer uma dobra, mas como nós temos interesse em como a soma irá progredir, faremos usando o scan. Uma vez tendo feito o scan, podemos ver quantas somas estão sob 1000. A primeira soma no resultado do scanlist será normalmente 1. O segundo será 1 mais a raiz quadrada de 2. O terceiro será a soma da raiz quadrada de 3. Se estas X somas estiverem abaixo de 1000, então somamos X+1 dos que excederem 1000.

Usamos aqui [code]takeWhile[/code] no lugar de [code]filter[/code] porque [code]filter[/code] não trabalha com listas infinitas. Apesar de sabermos que a lista é ascendente, [code]filter[/code] não faz assim, então usamos [code]takeWhile[/code] para terminar o scanlist na primeira ocorrência da soma maior do que 1000.
