title: Mapas e filtros

text: [fuction]map[/function] recebe uma função e uma lista e aplica esta função em todos elementos da lista, produzindo uma nova lista. Vamos ver qual é sua declaração de tipo e como ela é definida.

A declaração de tipo nos diz que ela recebe uma função que recebe um [code]a[/code] e retorna um [code]b[/code], uma lista de [code]a[/code]'s e retorna uma lista de [code]b[/code]'s. É interessante que ao dar apenas uma olhada na assinatura de tipos da função você pode algumas vezes dizer o que ela faz. [code]map[/code] é uma daquelas funções de alta ordem realmente versáteis que podem ser usadas em milhões de formas diferentes. Veja-a em ação:

Você provavelmente percebeu que tudo isso pode ser realizado com compreensões de lista. [code]map (+3) [1,5,3,1,6][/code] é o mesmo que escrever [code][x+3 | x &lt;- [1,5,3,1,6]][/code]. Porém, utilizar [code]map[/code] é muito mais legível em situações onde você somente aplica alguma função em um elemento da lista, especialmente quando você estiver lidando com mapas de mapas e a coisa toda com uma série de colchetes puder se tornar um pouco bagunçada.

[fuction]filter[/code] é uma função que recebe um predicado (um predicado é uma função que diz se alguma coisa é verdadeira ou não, portanto, nesse caso, uma função que retorna um valor booleano) e uma lista e então retorna a lista dos elementos que satisfazem o predicado. A declaração de tipo e a implementação podem ser os seguintes:

Bastante simples. Se [code]p x[/code] for avaliado como [code]True[/code], o elemento será incluido em uma nova lista. Se isto não acontecer, ficará de fora. Alguns exemplos de uso:

Tudo isto poderia também ser obtido com uma compreensão de lista e pelo uso de predicados. Não há um conjunto de regras para quando devemos utilizar [code]map[/code] e [code]filter[/code] ao invés de compreensão de lista, você só deve decidir qual será o mais légível dependendo do código e do contexto. O equivalente a aplicar diversos predicados em uma compreensão de lista, na forma de [code]filter[/code] seria ou filtrar algo diversas vezes ou juntar o predicado com a função lógica [code]&amp;&amp;[/code].

Lembra-se do nosso quicksort do <a href="recursion">capítulo anterior</a>? Utilizamos compreensões de lista para filtrar os elementos que eram menores do que (ou iguais a) e maior do que o pivô. Podemos obter a mesma funcionalidade de um jeito mais legível com o uso do [code]filter[/code]:

Mapeamento e filtragem são o pão com manteiga de toda a caixa de ferramenta do programador funcional. Não importa se você fizer isso com as funções [code]map[/code] e [code]filter[/code] ou com compreensão de lista. Lembre-se como resolvemos o problema para achar o triângulo retângulo com uma determinada circunferência. Com programação imperativa, nós deveriamos resolvê-lo aninhando três loops e então testando se a combinação atual satisfaz o triângulo retângulo e se tem o perímetro certo. Se este é o caso, teríamos que mostrá-lo na tela ou algo assim. Na programação funcional, este padrão é obtido com mapeamentos e filtragens. Você faz uma função que recebe um valor e produz algum resultado. Nós mapeamos esta função sobre uma lista de valores e então nós filtramos o resultado da lista para que os resultados satisfaçam a nossa busca. Graças à <i>preguiça</i> de Haskell, mesmo que você mapeie algo sobre uma lista várias vezes e filtre várias vezes, ele só irá passar pela lista uma vez.

Vamos <em>encontrar o maior número abaixo de 100.000 que é divisível por 3829</em>. Para fazer isso, vamos filtrar um conjunto de possibilidades em que nós sabemos que a solução consiste.

Primeiro vamos fazer uma lista com todos os números menores do que 100.000, em ordem decrescente. Então vamos filtrá-lo pelo nosso predicado e como os números são ordenados de forma decrescente, o maior número que irá satisfazer nosso predicado será o primeiro elemento filtrado da lista. Nem mesmo precisamos utilizar uma lista finita para o nosso conjunto inicial. Eis a preguiça em ação novamente. Como nós acabamos utilizando somente a <i>cabeça</i> da lista filtrada, não importa se a lista filtrada era finita ou infinita. A avaliação para quando a primeira solução adequada for encontrada.

Seguindo, nós queremos <em>obter a soma de todos os quadrados ímpares que sejam menores do que 10.000</em>. Mas primeiro, como iremos usá-lo em nossa solução, seremos introduzidos à função [function]takeWhile[/function]. Ela recebe um predicado e uma lista e então vai desde o inicio da lista retornando elementos enquanto eles satisfizerem o predicado. Uma vez que um elemento para o qual o predicado não for satisfeito for encontrado, ele para. Se nós quiséssemos pegar a primeira palavra da string [code]"elefantes é que sabem fazer festa"[/code], nós poderíamos fazer [code]takeWhile (/=' ') "elefantes é que sabem fazer festa"[/code] e isso retornaria [code]"elefantes"[/code]. Beleza. A soma de todos os quadrados ímpares que são menores do que 10.000. Primeiramente, vamos começar mapeando a função [code](^2)[/code] na lista infinita [code][1..]][/code]. Então filtramos somente os ímpares. E então vamos pegar elementos da lista enquanto eles forem menores que 10.000. Finalmente, vamos fazer a soma de toda essa lista. Nós nem mesmo precisamos definir uma função para isso, mas podemos fazê-lo em uma linha no GHCI:

Demais! Começamos com alguns dados iniciais (a lista infinita de todos os números naturais) e então nós mapeamos sobre isto, filtramos e cortamos até que se enquadre nas nossas necessidades e depois nós somamos. Também podíamos ter escrito isto utilizando compreensão de lista: 

É uma questão de gosto escolher a que você achar mais bonita. Novamente, a propriedade de <i>preguiça</i> do Haskell torna isto possível. Nós podemos mapear e filtrar uma lista infinita, porque ele na verdade não mapeia e filtra tudo de uma vez, mas atrasa essas ações. Somente quando forçamos o Haskell a mostrar para nós a soma é que que a função [code]sum[/code] diz para o [code]takeWhile[/code] que ele precisa daqueles números. [code]takeWhile[/code] força que o mapeamento e a filtragem ocorra, mas somente até que um número maior ou igual do que 10.000 seja encontrado.

Em nosso próximo problema, lidaremos com a <a href="http://pt.wikipedia.org/wiki/Conjectura_de_Collatz" target="_blank">sequências de Collatz</a>. Nós pegamos um número natural. Se ele for par, dividimos por dois. Se for ímpar, multiplicamos ele por 3 e então somamos 1 a ele. Pegamos o número resultante e aplicamos a mesma coisa nele, produzindo um novo número, e assim por diante. Na essência, nós temos uma sequência de números. Acredita-se que para todos os números iniciais, a sequência termina no número 1. Então se tivermos inicialmente o número 13, teremos esta sequência: <i>13, 40, 20, 10, 5, 16, 8, 4, 2, 1</i>. 13*3 + 1 é igual a 40. 40 dividido por 2 é 20, etc. Vemos que a sequência tem 10 termos.

Agora o que nós queremos saber é: <em> para todos os números iniciais entre 1 e 100, quantas sequências tem com um comprimento maior do que 15?</em> Primeiramente, vamos escrever uma função para obter uma sequência:

Como a sequência termina em 1, esse seria o caso de limite. Essa é uma função recursiva bem padrão.

Yay! Parece estar funcionando corretamente. E agora, a função que nos diz a resposta à nossa pergunta:

Mapeamos a função [code]chain[/code] em [code][1..100][/code] para obter uma lista de sequências, que são, por sua vez, representadas como listas. Então os filtramos com um predicado que apenas checa se o comprimento de uma lista é maior do que 15. Uma vez que tenhamos filtrado, conseguimos ver quantas sequências são deixadas na lista resultante.

<em>Nota:</em> Esta função tem o tipo [code]numLongChains :: Int[/code] porque [code]length[/code] retorna um [code]Int[/code] em vez de um [code]Num a[/code] por razões históricas. Se quiséssemos retornar um [code]Num a[/code], mais geral, poderíamos ter usado [code]fromIntegral[/code] no comprimento resultante.

Usando [code]map[/code], nós também podemos fazer coisas como [code]map (*) [0..][/code], se não por qualquer outra razão, então para ilustrar como <i>currying</i> funciona e como funções (parcialmente aplicadas) são valores reais que você pode passar para outras funções ou pôr em listas (você apenas não pode torná-las strings). Até aqui, nós somente mapeamos funções que aplicam um parâmetro sobre listas, como [code]map (*2) [0..][/code] para pegar uma lista do tipo [code](Num a) => [a][/code], mas nós podemos também fazer [code]map (*) [0..][/code] sem problemas. O que acontece aqui é que ao número na lista é aplicada a função [code]*[/code], que tem o tipo de [code](Num a) => a -> a -> a[/code]. Aplicar apenas um parâmetro a uma funão que recebe dois parâmetros retorna uma função que recebe um parâmetro. Se nós mapearmos [code]*[/code] sobre a lista [code][0..][/code], então nós receberemos de volta uma lista de funções que recebem apenas um parâmetro, ou seja [code](Num a) => [a -> a][/code]. [code]map (*) [0..][/code] produz uma lista como aquela que receberíamos ao escrever [code][(0*),(1*),(2*),(3*),(4*),(5*)..[/code].

Pegar o elemento com índice [code]4[/code] da nossa lista retorna uma funão que é equivalente a [code](4*)[/code]. E então, nós apenas aplicamos [code]5[/code] a aquela função. Então isso é como escrever [code](4*) 5[/code] ou apenas [code]4 * 5[/code].
